{"version":3,"file":"static/js/88.0f38a681.chunk.js","mappings":"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","sources":["../node_modules/psl/index.js","../node_modules/punycode/punycode.es6.js"],"sourcesContent":["/*eslint no-var:0, prefer-arrow-callback: 0, object-shorthand: 0 */\n'use strict';\n\n\nvar Punycode = require('punycode');\n\n\nvar internals = {};\n\n\n//\n// Read rules from file.\n//\ninternals.rules = require('./data/rules.json').map(function (rule) {\n\n  return {\n    rule: rule,\n    suffix: rule.replace(/^(\\*\\.|\\!)/, ''),\n    punySuffix: -1,\n    wildcard: rule.charAt(0) === '*',\n    exception: rule.charAt(0) === '!'\n  };\n});\n\n\n//\n// Check is given string ends with `suffix`.\n//\ninternals.endsWith = function (str, suffix) {\n\n  return str.indexOf(suffix, str.length - suffix.length) !== -1;\n};\n\n\n//\n// Find rule for a given domain.\n//\ninternals.findRule = function (domain) {\n\n  var punyDomain = Punycode.toASCII(domain);\n  return internals.rules.reduce(function (memo, rule) {\n\n    if (rule.punySuffix === -1){\n      rule.punySuffix = Punycode.toASCII(rule.suffix);\n    }\n    if (!internals.endsWith(punyDomain, '.' + rule.punySuffix) && punyDomain !== rule.punySuffix) {\n      return memo;\n    }\n    // This has been commented out as it never seems to run. This is because\n    // sub tlds always appear after their parents and we never find a shorter\n    // match.\n    //if (memo) {\n    //  var memoSuffix = Punycode.toASCII(memo.suffix);\n    //  if (memoSuffix.length >= punySuffix.length) {\n    //    return memo;\n    //  }\n    //}\n    return rule;\n  }, null);\n};\n\n\n//\n// Error codes and messages.\n//\nexports.errorCodes = {\n  DOMAIN_TOO_SHORT: 'Domain name too short.',\n  DOMAIN_TOO_LONG: 'Domain name too long. It should be no more than 255 chars.',\n  LABEL_STARTS_WITH_DASH: 'Domain name label can not start with a dash.',\n  LABEL_ENDS_WITH_DASH: 'Domain name label can not end with a dash.',\n  LABEL_TOO_LONG: 'Domain name label should be at most 63 chars long.',\n  LABEL_TOO_SHORT: 'Domain name label should be at least 1 character long.',\n  LABEL_INVALID_CHARS: 'Domain name label can only contain alphanumeric characters or dashes.'\n};\n\n\n//\n// Validate domain name and throw if not valid.\n//\n// From wikipedia:\n//\n// Hostnames are composed of series of labels concatenated with dots, as are all\n// domain names. Each label must be between 1 and 63 characters long, and the\n// entire hostname (including the delimiting dots) has a maximum of 255 chars.\n//\n// Allowed chars:\n//\n// * `a-z`\n// * `0-9`\n// * `-` but not as a starting or ending character\n// * `.` as a separator for the textual portions of a domain name\n//\n// * http://en.wikipedia.org/wiki/Domain_name\n// * http://en.wikipedia.org/wiki/Hostname\n//\ninternals.validate = function (input) {\n\n  // Before we can validate we need to take care of IDNs with unicode chars.\n  var ascii = Punycode.toASCII(input);\n\n  if (ascii.length < 1) {\n    return 'DOMAIN_TOO_SHORT';\n  }\n  if (ascii.length > 255) {\n    return 'DOMAIN_TOO_LONG';\n  }\n\n  // Check each part's length and allowed chars.\n  var labels = ascii.split('.');\n  var label;\n\n  for (var i = 0; i < labels.length; ++i) {\n    label = labels[i];\n    if (!label.length) {\n      return 'LABEL_TOO_SHORT';\n    }\n    if (label.length > 63) {\n      return 'LABEL_TOO_LONG';\n    }\n    if (label.charAt(0) === '-') {\n      return 'LABEL_STARTS_WITH_DASH';\n    }\n    if (label.charAt(label.length - 1) === '-') {\n      return 'LABEL_ENDS_WITH_DASH';\n    }\n    if (!/^[a-z0-9\\-]+$/.test(label)) {\n      return 'LABEL_INVALID_CHARS';\n    }\n  }\n};\n\n\n//\n// Public API\n//\n\n\n//\n// Parse domain.\n//\nexports.parse = function (input) {\n\n  if (typeof input !== 'string') {\n    throw new TypeError('Domain name must be a string.');\n  }\n\n  // Force domain to lowercase.\n  var domain = input.slice(0).toLowerCase();\n\n  // Handle FQDN.\n  // TODO: Simply remove trailing dot?\n  if (domain.charAt(domain.length - 1) === '.') {\n    domain = domain.slice(0, domain.length - 1);\n  }\n\n  // Validate and sanitise input.\n  var error = internals.validate(domain);\n  if (error) {\n    return {\n      input: input,\n      error: {\n        message: exports.errorCodes[error],\n        code: error\n      }\n    };\n  }\n\n  var parsed = {\n    input: input,\n    tld: null,\n    sld: null,\n    domain: null,\n    subdomain: null,\n    listed: false\n  };\n\n  var domainParts = domain.split('.');\n\n  // Non-Internet TLD\n  if (domainParts[domainParts.length - 1] === 'local') {\n    return parsed;\n  }\n\n  var handlePunycode = function () {\n\n    if (!/xn--/.test(domain)) {\n      return parsed;\n    }\n    if (parsed.domain) {\n      parsed.domain = Punycode.toASCII(parsed.domain);\n    }\n    if (parsed.subdomain) {\n      parsed.subdomain = Punycode.toASCII(parsed.subdomain);\n    }\n    return parsed;\n  };\n\n  var rule = internals.findRule(domain);\n\n  // Unlisted tld.\n  if (!rule) {\n    if (domainParts.length < 2) {\n      return parsed;\n    }\n    parsed.tld = domainParts.pop();\n    parsed.sld = domainParts.pop();\n    parsed.domain = [parsed.sld, parsed.tld].join('.');\n    if (domainParts.length) {\n      parsed.subdomain = domainParts.pop();\n    }\n    return handlePunycode();\n  }\n\n  // At this point we know the public suffix is listed.\n  parsed.listed = true;\n\n  var tldParts = rule.suffix.split('.');\n  var privateParts = domainParts.slice(0, domainParts.length - tldParts.length);\n\n  if (rule.exception) {\n    privateParts.push(tldParts.shift());\n  }\n\n  parsed.tld = tldParts.join('.');\n\n  if (!privateParts.length) {\n    return handlePunycode();\n  }\n\n  if (rule.wildcard) {\n    tldParts.unshift(privateParts.pop());\n    parsed.tld = tldParts.join('.');\n  }\n\n  if (!privateParts.length) {\n    return handlePunycode();\n  }\n\n  parsed.sld = privateParts.pop();\n  parsed.domain = [parsed.sld,  parsed.tld].join('.');\n\n  if (privateParts.length) {\n    parsed.subdomain = privateParts.join('.');\n  }\n\n  return handlePunycode();\n};\n\n\n//\n// Get domain.\n//\nexports.get = function (domain) {\n\n  if (!domain) {\n    return null;\n  }\n  return exports.parse(domain).domain || null;\n};\n\n\n//\n// Check whether domain belongs to a known public suffix.\n//\nexports.isValid = function (domain) {\n\n  var parsed = exports.parse(domain);\n  return Boolean(parsed.domain && parsed.listed);\n};\n","'use strict';\n\n/** Highest positive signed 32-bit float value */\nconst maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nconst base = 36;\nconst tMin = 1;\nconst tMax = 26;\nconst skew = 38;\nconst damp = 700;\nconst initialBias = 72;\nconst initialN = 128; // 0x80\nconst delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nconst regexPunycode = /^xn--/;\nconst regexNonASCII = /[^\\0-\\x7F]/; // Note: U+007F DEL is excluded too.\nconst regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nconst errors = {\n\t'overflow': 'Overflow: input needs wider integers to process',\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nconst baseMinusTMin = base - tMin;\nconst floor = Math.floor;\nconst stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error(type) {\n\tthrow new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, callback) {\n\tconst result = [];\n\tlet length = array.length;\n\twhile (length--) {\n\t\tresult[length] = callback(array[length]);\n\t}\n\treturn result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {String} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(domain, callback) {\n\tconst parts = domain.split('@');\n\tlet result = '';\n\tif (parts.length > 1) {\n\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t// the local part (i.e. everything up to `@`) intact.\n\t\tresult = parts[0] + '@';\n\t\tdomain = parts[1];\n\t}\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\tdomain = domain.replace(regexSeparators, '\\x2E');\n\tconst labels = domain.split('.');\n\tconst encoded = map(labels, callback).join('.');\n\treturn result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n\tconst output = [];\n\tlet counter = 0;\n\tconst length = string.length;\n\twhile (counter < length) {\n\t\tconst value = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// It's a high surrogate, and there is a next character.\n\t\t\tconst extra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) { // Low surrogate.\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nconst ucs2encode = codePoints => String.fromCodePoint(...codePoints);\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nconst basicToDigit = function(codePoint) {\n\tif (codePoint >= 0x30 && codePoint < 0x3A) {\n\t\treturn 26 + (codePoint - 0x30);\n\t}\n\tif (codePoint >= 0x41 && codePoint < 0x5B) {\n\t\treturn codePoint - 0x41;\n\t}\n\tif (codePoint >= 0x61 && codePoint < 0x7B) {\n\t\treturn codePoint - 0x61;\n\t}\n\treturn base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nconst digitToBasic = function(digit, flag) {\n\t//  0..25 map to ASCII a..z or A..Z\n\t// 26..35 map to ASCII 0..9\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nconst adapt = function(delta, numPoints, firstTime) {\n\tlet k = 0;\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\tdelta += floor(delta / numPoints);\n\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\tdelta = floor(delta / baseMinusTMin);\n\t}\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nconst decode = function(input) {\n\t// Don't use UCS-2.\n\tconst output = [];\n\tconst inputLength = input.length;\n\tlet i = 0;\n\tlet n = initialN;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points: let `basic` be the number of input code\n\t// points before the last delimiter, or `0` if there is none, then copy\n\t// the first basic code points to the output.\n\n\tlet basic = input.lastIndexOf(delimiter);\n\tif (basic < 0) {\n\t\tbasic = 0;\n\t}\n\n\tfor (let j = 0; j < basic; ++j) {\n\t\t// if it's not a basic code point\n\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\terror('not-basic');\n\t\t}\n\t\toutput.push(input.charCodeAt(j));\n\t}\n\n\t// Main decoding loop: start just after the last delimiter if any basic code\n\t// points were copied; start at the beginning otherwise.\n\n\tfor (let index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t// `index` is the index of the next character to be consumed.\n\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t// which gets added to `i`. The overflow checking is easier\n\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t// value at the end to obtain `delta`.\n\t\tconst oldi = i;\n\t\tfor (let w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\tif (index >= inputLength) {\n\t\t\t\terror('invalid-input');\n\t\t\t}\n\n\t\t\tconst digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\tif (digit >= base) {\n\t\t\t\terror('invalid-input');\n\t\t\t}\n\t\t\tif (digit > floor((maxInt - i) / w)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\ti += digit * w;\n\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\tif (digit < t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst baseMinusT = base - t;\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tw *= baseMinusT;\n\n\t\t}\n\n\t\tconst out = output.length + 1;\n\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t// incrementing `n` each time, so we'll fix that now:\n\t\tif (floor(i / out) > maxInt - n) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tn += floor(i / out);\n\t\ti %= out;\n\n\t\t// Insert `n` at position `i` of the output.\n\t\toutput.splice(i++, 0, n);\n\n\t}\n\n\treturn String.fromCodePoint(...output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nconst encode = function(input) {\n\tconst output = [];\n\n\t// Convert the input in UCS-2 to an array of Unicode code points.\n\tinput = ucs2decode(input);\n\n\t// Cache the length.\n\tconst inputLength = input.length;\n\n\t// Initialize the state.\n\tlet n = initialN;\n\tlet delta = 0;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points.\n\tfor (const currentValue of input) {\n\t\tif (currentValue < 0x80) {\n\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t}\n\t}\n\n\tconst basicLength = output.length;\n\tlet handledCPCount = basicLength;\n\n\t// `handledCPCount` is the number of code points that have been handled;\n\t// `basicLength` is the number of basic code points.\n\n\t// Finish the basic string with a delimiter unless it's empty.\n\tif (basicLength) {\n\t\toutput.push(delimiter);\n\t}\n\n\t// Main encoding loop:\n\twhile (handledCPCount < inputLength) {\n\n\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t// larger one:\n\t\tlet m = maxInt;\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\tm = currentValue;\n\t\t\t}\n\t\t}\n\n\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t// but guard against overflow.\n\t\tconst handledCPCountPlusOne = handledCPCount + 1;\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\tn = m;\n\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\t\t\tif (currentValue === n) {\n\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\tlet q = delta;\n\t\t\t\tfor (let k = base; /* no condition */; k += base) {\n\t\t\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst qMinusT = q - t;\n\t\t\t\t\tconst baseMinusT = base - t;\n\t\t\t\t\toutput.push(\n\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t);\n\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t}\n\n\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);\n\t\t\t\tdelta = 0;\n\t\t\t\t++handledCPCount;\n\t\t\t}\n\t\t}\n\n\t\t++delta;\n\t\t++n;\n\n\t}\n\treturn output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nconst toUnicode = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexPunycode.test(string)\n\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t: string;\n\t});\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nconst toASCII = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexNonASCII.test(string)\n\t\t\t? 'xn--' + encode(string)\n\t\t\t: string;\n\t});\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nconst punycode = {\n\t/**\n\t * A string representing the current Punycode.js version number.\n\t * @memberOf punycode\n\t * @type String\n\t */\n\t'version': '2.3.1',\n\t/**\n\t * An object of methods to convert from JavaScript's internal character\n\t * representation (UCS-2) to Unicode code points, and back.\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode\n\t * @type Object\n\t */\n\t'ucs2': {\n\t\t'decode': ucs2decode,\n\t\t'encode': ucs2encode\n\t},\n\t'decode': decode,\n\t'encode': encode,\n\t'toASCII': toASCII,\n\t'toUnicode': toUnicode\n};\n\nexport { ucs2decode, ucs2encode, decode, encode, toASCII, toUnicode };\nexport default punycode;\n"],"names":["Punycode","require","internals","rules","rule","suffix","replace","punySuffix","wildcard","charAt","exception","endsWith","str","indexOf","length","findRule","domain","punyDomain","toASCII","reduce","memo","exports","errorCodes","DOMAIN_TOO_SHORT","DOMAIN_TOO_LONG","LABEL_STARTS_WITH_DASH","LABEL_ENDS_WITH_DASH","LABEL_TOO_LONG","LABEL_TOO_SHORT","LABEL_INVALID_CHARS","validate","input","ascii","label","labels","split","i","test","parse","TypeError","slice","toLowerCase","error","message","code","parsed","tld","sld","subdomain","listed","domainParts","handlePunycode","pop","join","tldParts","privateParts","push","shift","unshift","get","isValid","Boolean","maxInt","base","regexPunycode","regexNonASCII","regexSeparators","errors","floor","Math","stringFromCharCode","String","fromCharCode","type","RangeError","mapDomain","callback","parts","result","encoded","array","map","ucs2decode","string","output","counter","value","charCodeAt","extra","ucs2encode","codePoints","fromCodePoint","digitToBasic","digit","flag","adapt","delta","numPoints","firstTime","k","baseMinusTMin","decode","inputLength","n","bias","basic","lastIndexOf","j","index","oldi","w","codePoint","t","baseMinusT","out","splice","encode","currentValue","basicLength","handledCPCount","m","handledCPCountPlusOne","q","qMinusT","toUnicode"],"sourceRoot":""}